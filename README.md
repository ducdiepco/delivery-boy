# README

## Запуск приложения
Для того чтобы запустить приложение можно было быстро и без установки лишних плагинов 
(таких как rabbitmq-delayed-message-exchange) я решил упаковать его в докер.

Вам необходим `docker-compose`. 
В папке приложения нужно ввести `docker-compose build`.
После чего освободить порты `5672`, `15672`, `5432`, `3000`.
Если у вас запущена PostgreSql отключите её командой `sudo /etc/init.d/postgresql stop`.
После всех этих операции надо выполнить команду `docker-compose-up`.

Должно подняться 4 контейнера:
* Само веб приложение
* БД postgresql
* RabbitMq
* Sneakers - воркеры

## API - запросы
#####POST /api/messages

    # Создаёт сообщения для рассылки,
    # после чего кладёт их в очередь для отправки в зависимости от времени
    #
    # Данные должны быть в формате json, в хедере запроса должно быть выставлено значение:
    #   Content-Type - application/json
    #
    # Пример запроса:
    #
    # {"message":
    #   {
    #     "body":"hello my darling",
    #     "consumers_info":[
    #       {
    #         "time_to_deliver": 1558181088,
    #         "messenger_user_id": 2,
    #         "messenger": "whats_app"
    #       },
    #       {
    #         "messenger_user_id": 3,
    #         "messenger": "whats_app"
    #       }
    #     ]
    #   }
    # }
    #
    #  Описание аттрибутов:
    #    message/body - string. Обязательный параметр, текст сообщения длина может быть от 1 до 500
    #
    #    message/consumers_info - array. Обязательный параметр, массив из хешей, в котором указываются
    #                             мессенджеры, пользователи и время для отправки сообщения
    #
    #    message/consumers_info/messenger_user_id - integer. Обязательный параметр, id пользователя
    #    message/consumers_info/messenger - string. Обязательный параметр, мессенджер, куда отправляются
    #                                       сообщения. Может быть равен 'viber', 'whatsapp', 'telegram'.
    #                                       (Для примера сделал так, что все сообщения на whatsapp будут
    #                                        получать статус failed в очереди).
    #    message/consumers_info/time_to_deliver - timestamp - integer. Опциональный параметр, время, когда сообщение
    #                                             должно быть доставлено. Если время меньше текущего, то сообщение
    #                                             отправляется незамедлительно.
    #
    # Ответ
    #   В случае валидного запроса:
    #   Результат: Массив из созданных сообщений в системе в том порядке, в котором они были указаны при запросе
    #   Пример:
    #   {
    #     "status": "accepted",
    #     "ids": [1, 2]
    #   }
    #
    #   В случае, невалидного запроса
    #   Результат: Хэш с ошибками в формате:
    #    {"reasons": {"body": [массив строк с описанием ошибок],
    #                 "consumer_info":
    #                   { Порядковый номер сообщения в запросе: {невалидное поле: [массив строк с описанием ошибок]]}}}
    #                }
    #    }
    #
    #   Пример:
    #   {
    #    "status": "invalid_data",
    #      "reasons": {
    #          "body": [
    #              "must be filled",
    #              "length must be within 1 - 500"
    #          ],
    #          "consumers_info": {
    #              "2": {
    #                  "messenger": [
    #                      "must be one of: telegram, whats_app, viber"
    #                  ]
    #              }
    #          }
    #      }
    #  }
    #

##### GET /api/messages/:id
    # Возращает запись Message в json-формате


## Стек технологий/инструментов
* `dry-monads`, `dry-transaction`, `dry-validation`
  - Выбрал потому что код с этими гемами намного чище и лучше читается.
* Почему rabbitmq c `sneakers`, вместо delayed_job или sidekiq?
  - Реббит намного надёжнее редиса.
  - Само задание (а именно пункты 3, 4) подразумевало использование мессадж брокера. Единственное в чём была проблема, 
  так это в том, что реббит не умеет посылать отложенные сообщения из коробки и на реальном проекте я бы подумал о другом мессандж брокере или о крон таске, 
  но, для этого использовал плагин, который позволяет отправлять отложенные сообщения.
  - Личные предпочтения
## Функционал
* прием сообщений по API и отправка их в мессенджеры (с указанием
  идентификатора пользователя для каждого мессенджера)
   - есть

* возможность отложенной отправки сообщений по дате/времени; 
  - есть, реализовал с помощью rabbitmq и плагина `rabbitmq-delayed-message-exchange`.


* в случае неудачной отправки сообщения, нужно повторить попытку N-ое
  количество раз, но это не должно влиять на доставляемость других сообщений; 
  - Eсть, переменная - `Message::MAX_NUMBER_OF_RETRIES`
  
* исключение возможности многократной отправки одного и того же сообщения (с одним и тем же содержимым) одному получателю;
  - Есть, rabbitmq исключает возможность отправки одного сообщения несколько раз.

* возможность отправки одного сообщения нескольким получателям на несколько мессенджеров в рамках одного запроса;
  - Есть
* Клёвый readme
  - есть  